<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //         NB: These game instructions only focus on the last three digits of a draw number. Eg. x,x,5,4,3
        // Pair exists: there is a pair in the draw. Eg. x,x,1,1,2
        // No pair: there is no pair in the draw. Eg. x,x,1,2,3
        // Big dominates: big(5-9) is more than small(0-4). Eg. x,x,5,7,1
        // Small dominates: small(0-4) is more than big(5-9). Eg. x,x,1,2,7
        // Odd dominates: odd(1,3,5,7,9) is more than even(0,2,4,6,8). Eg. x,x,1,3,4
        // Even dominates: even(0,2,4,6,8) is more than odd(1,3,5,7,9). Eg. x,x,2,4,5
        // All are big: all three numbers(last three) are big(5-9). Eg. x,x,5,7,9
        // All are small: all three numbers(last three) are small(0-4). Eg. x,x,1,2,3
        // All are odd: all three numbers(last three) are odd(1,3,5,7,9). Eg. x,x,1,3,5
        // All are even: all three numbers(last three) are even(0,2,4,6,8). Eg. x,x,2,4,6

        // function generateCombinationsWithRepetitions(arr, length) {
        //     if (length === 0) {
        //         return [[]];
        //     } else {
        //         const combinations = [];
        //         for (let i = 0; i < arr.length; i++) {
        //             const element = arr[i];
        //             const subCombinations = generateCombinationsWithRepetitions(arr, length - 1);
        //             for (let j = 0; j < subCombinations.length; j++) {
        //                 const subCombination = subCombinations[j];
        //                 combinations.push([element].concat(subCombination));
        //             }
        //         }
        //         return combinations;
        //     }
        // }



        function arrayContained(needles, haystack) {
            const count1 = {};
            const count2 = {};

            // count frequency of elements in haystack 
            for (let i = 0; i < haystack.length; i++) {
                count1[haystack[i]] = (count1[haystack[i]] || 0) + 1;
            }

            // count frequency of elements in needles 
            for (let i = 0; i < needles.length; i++) {
                count2[needles[i]] = (count2[needles[i]] || 0) + 1;
            }

            // check if each element in needles appears <= its frequency in haystack 
            for (const [key, value] of Object.entries(count2)) {
                if (!(key in count1) || count1[key] < value) {
                    return false;
                }
            }

            return true;
        }


        let sum = (arr) => {
            return arr.reduce(function (acc, val) {
                return acc += val;
            }, 0)
        }
        function allPossibleNumbers(lengthDigits, target) {
            let upTo = 10 ** lengthDigits;
            let strNum, intArr;
            let allPossibleNumbers = [];
            if (target) {
                for (let i = 0; i < upTo; i++) {
                    strNum = String(i).padStart(lengthDigits, 0);
                    intArr = strNum.split('').map(num => +num);
                    arrayContained(target, intArr) ? allPossibleNumbers.push(intArr) : null;
                }
                return allPossibleNumbers;
            }

            for (let i = 0; i < upTo; i++) {
                strNum = String(i).padStart(lengthDigits, 0);
                intArr = strNum.split('').map(num => +num);
                if (target) {
                    arrayContained(target, intArr) ? allPossibleNumbers.push(intArr) : null;
                } else
                    allPossibleNumbers.push(intArr);
            }
            return allPossibleNumbers;
        }

        let elements = allPossibleNumbers(5)
        let found = [];

        // checking if the first element is the largest in five elements in the array
        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     let fourthEl = element[3];
        //     let fifthEl = element[4];
        //     if(secondEl > firstEl && secondEl > thirdEl && secondEl > fourthEl && secondEl > fifthEl){
        //         found.push(element)
        //     }
        // })
        // console.log(found);

        //checking if two elements are the largest in the array
        //example [5,4,3,0,5]. this function checks for exactly two elements being the largest in the array

        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     let fourthEl = element[3];
        //     let fifthEl = element[4];
        //     if(firstEl > secondEl && firstEl > thirdEl && firstEl > fourthEl && firstEl > fifthEl){
        //         found.push(element)
        //     }
        // })
        // let foundLen = found.length;
        // let odds = 100000/foundLen;
        // console.log(odds);
        // console.log(found);

        //checking if all five elements are same
        elements.forEach(element=>{
            let firstEl = element[0];
            let secondEl = element[1];
            let thirdEl = element[2];
            let fourthEl = element[3];
            let fifthEl = element[4];
            if((firstEl == secondEl && firstEl > thirdEl && firstEl > fourthEl && firstEl > fifthEl)||
            (firstEl > secondEl && firstEl == thirdEl && firstEl > fourthEl && firstEl > fifthEl)||
            (firstEl > secondEl && firstEl > thirdEl && firstEl == fourthEl && firstEl > fifthEl)||
            (firstEl > secondEl && firstEl > thirdEl && firstEl > fourthEl && firstEl == fifthEl)){
                found.push(element)
            }
        })
        console.log(found);

        // elements.forEach(element=>{
        //     if(sum(element)>=0 && sum(element)<=4){
        //         found.push(element)
        //     }
        // })
        // console.log(found);

        // checking if pair exists
        // elements.forEach(element => {
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     if (firstEl === secondEl || firstEl === thirdEl || secondEl === thirdEl) {
        //         found.push(element)
        //     }
        // });
        // console.log(found);
        //checking if no pair exists
        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     if(firstEl !== secondEl && firstEl !== thirdEl && secondEl !== thirdEl){
        //         found.push(element)
        //     }
        // })
        // console.log(found);

        //checking if big dominates. this means either 2 or more of the elements are big

        // elements.forEach(element => {
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     if ((firstEl >= 5 && secondEl >= 5) || (firstEl >= 5 && thirdEl >= 5) || (secondEl>=5 && thirdEl >=5)) {
        //         found.push(element)
        //     }
        // })
        // console.log(found);

        //checking if small dominates. this means either 2 or more of the elements are small
        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     if((firstEl <= 4 && secondEl <= 4) || (firstEl <= 4 && thirdEl <= 4) || (secondEl <= 4 && thirdEl <= 4)){
        //         found.push(element)
        //     }
        // })
        // console.log(found);

        // checking if all are big
        //  elements.forEach(element=>{
        //         let firstEl = element[0];
        //         let secondEl = element[1];
        //         let thirdEl = element[2];
        //         if(firstEl >= 5 && secondEl >= 5 && thirdEl >= 5){
        //             found.push(element)
        //         }
        //  })
        //     console.log(found);
        //fantan redraw
        // elements.forEach(element => {
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     let fourthEl = element[3];
        //     let fifthEl = element[4];
        //     if((thirdEl === 2 && fourthEl === 2 && fifthEl === 2) || (thirdEl === 3 && fourthEl === 3 && fifthEl === 3) || (thirdEl === 6 && fourthEl === 6 && fifthEl === 6) || (thirdEl === 7 && fourthEl === 7 && fifthEl === 7)){
        //         found.push(element)
        //     }
        // })
        // console.log(found);
        //B/S/O/E FIRST AND LAST
        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     let thirdEl = element[2];
        //     firstEl <= 4 && secondEl >= 5 && thirdEl <= 4 ? found.push(element):null;
        // })
        // console.log(elements)

        //B/S/O/E sum of all 5
        //         elements.forEach(element=>{
        //             let elSum = sum(element);
        //             elSum>=0 && elSum<=22 ? found.push(element) : null;
        //         })
        // console.log(found)

        // elements.forEach(element=>{
        //     let firstEl = element[0];
        //     let secondEl = element[1];
        //     firstEl<secondEl ? found.push(element) : null;
        // })
        // console.log(found)

        // fantan - back
        // let findOdds = (values, elements) => {
        //     let results = {};
        //     count = 0;
        //     values.forEach(value => {
        //         elements.forEach(element => {
        //             if (sum(element) == value) {
        //                 ++count;
        //             }
        //         })
        //         results[value] = 1000 / count;
        //         count = 0;
        //     })
        //     console.log(results)
        // }

        // findOdds([5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22], elements);


        //fantan - sum of
        // let findOdds = (values, elements) => {
        //     let results = {};
        //     count = 0;
        //     values.forEach(value => {
        //         let min = value[0];
        //         let max = value[1];
        //         elements.forEach(element => {
        //             if (sum(element) >= min && sum(element) <= max) {
        //                 ++count;
        //             }
        //         })
        //         let key = min + "-" + max;
        //         results[key] = 1000 / count;
        //         count = 0;
        //     })
        //     console.log(results)
        // }

        // findOdds([[0, 3], [4, 7], [8, 11], [12, 15], [16, 19], [20, 23], [24, 27]], elements);

        // let elements = generateCombinationsWithRepetitions([0,1,2,3,4,5,6,7,8,9], 5);
        // console.log(elements)
        //         let arrayContaineds = (needles, haystack) => {
        //            return needles.every(needle => { return haystack.includes(needle) })
        //         }


        //         // arrayContained([1,1], [1,3,2]);


        let countAll = (needles, elements) => {
            let counter = 0;
            let found = []
            elements.forEach(element => {
                if (arrayContained(needles, element)) {
                    ++counter;
                    found.push(element);
                }
            });
            return found;
        }


        //     let mainBull, subBull; 
        //     let results;
        //     let storage = new Set();
        //    elements.reduce((acc, value)=> {
        //         mainBull = value.slice(0,3);
        //         subBull  = value.slice(3)
        //         if ((sum(mainBull) == 0 || sum(mainBull) % 10 == 0) && (sum(subBull) == 1 || sum(subBull) == 11)) {
        //              results = countAll(value, elements);
        //              console.log(results)
        //              results.forEach(val=>{
        //                 storage.add(val.join('-'));
        //              })
        //         }
        //         return acc
        //      }, 0)
        // const storage = new Set();

        // for (const value of elements) {
        //     const [mainBull, subBull] = [value.slice(0, 3), value.slice(3)];
        //     const mainSum = sum(mainBull);
        //     let subSum = sum(subBull);
        //     //   let subSumArr = String(subSum).split('')
        //     //   subSum =  +subSumArr[1] || +subSumArr[0];
        //     if ((mainSum !== 0 && mainSum % 10 !== 0)) {
        //         const results = getPermutations(value, 5);
        //         for (const val of results) {
        //             storage.add(val.join('-'));
        //         }
        //     }
        // }

        //No Bull
        function generateValidArraysWithRepeats() {
            const validArrays = [];
            for (let i = 0; i <= 9; i++) {
                for (let j = 0; j <= 9; j++) {
                    for (let k = 0; k <= 9; k++) {
                        for (let l = 0; l <= 9; l++) {
                            for (let m = 0; m <= 9; m++) {
                                const array = [i, j, k, l, m];
                                let isValid = true;
                                for (let x = 0; x < 5 && isValid; x++) {
                                    for (let y = x + 1; y < 5 && isValid; y++) {
                                        for (let z = y + 1; z < 5 && isValid; z++) {
                                            const sum = array[x] + array[y] + array[z];
                                            if (sum === 0 || sum % 10 === 0) {
                                                isValid = false;
                                            }
                                        }
                                    }
                                }
                                if (isValid) {
                                    validArrays.push(array);
                                }
                            }
                        }
                    }
                }
            }
            return validArrays;
        }



        // console.log(storage)
        //     console.log(yop)



        //       let allNotIn = (needles, elements)=>{
        //           let counter = 0;
        //           needles = [2,2];
        //           let found = []
        //           elements.forEach(element => {

        //               if(!arrayContained(needles, element)){
        //                   ++counter;
        //                   found.push(element);
        //               }
        //           });
        //       }
        // console.log(found)
        //    console.log(counter)


        //  console.log(found)
        function getPermutations(arr, n) {
            const result = new Set();

            // Define a recursive helper function to generate permutations
            function generate(current, remaining) {
                // Base case: we've selected enough elements
                if (current.length === n) {
                    result.add(current.join('-')); // Use a separator to avoid duplicates
                    return;
                }

                // Recursive case: generate permutations for each remaining element
                for (let i = 0; i < remaining.length; i++) {
                    const next = current.concat(remaining[i]);
                    const remainingSubset = remaining.slice(0, i).concat(remaining.slice(i + 1));
                    generate(next, remainingSubset);
                }
            }

            generate([], arr);
            return Array.from(result, str => str.split('-').map(Number));
        }





        // let test2 = getPermutations([0,2,4], 3)
        // let test2 = getPermutations([0,1,0], 3)
        // let test2 = getPermutations([1,1,1,5,1],5)

        // console.log(test2);


    </script>
</body>

</html>

LOTTERY: FANTAN

/***************FANTAN MAIN***************/<br />
*small: when sum of five numbers is between (0-22) inclusive eg. 1,1,1,1,1<br /><br />
*big: when sum of five numbers is between (23-45) inclusive eg. 9,9,9,9,9<br />
*odd(one): when sum of five numbers is odd eg. 1,1,1,1,1<br />
*even(pair): when sum of five numbers is even. eg. 1,1,1,1,2<br />
*dragon: when first number is greater than last number eg. 9,x,x,x,x,1<br />
*tiger: when first number is less than last number eg. 1,x,x,x,x,9<br />
*tie(and): when first number is equal to last number eg. 1,x,x,x,x,1<br />
*fan 1: when the sum of the five numbers divided by 4 gives a remainder of 1. eg. 9,1,8,2,1<br />
*fan 2: when the sum of the five numbers divided by 4 gives a remainder of 2. eg. 9,1,8,2,2<br />
*fan 3: when the sum of the five numbers divided by 4 gives a remainder of 3. eg. 9,1,8,2,3<br />
*fan 4: when the sum of the five numbers divided by 4 gives a remainder of 0. eg. 9,1,8,2,4<br />
*ten thousand: when the first number is the largest. eg. 5,4,3,2,1<br />
*thousand: when the second number is the largest. eg. 1,5,3,2,1<br />
*hundred: when the third number is the largest. eg. 1,2,5,3,1<br />
*ten: when the fourth number is the largest. eg. 1,2,3,5,1<br />
*one: when the fifth number is the largest. eg. 1,2,3,4,5<br />
/***************FANTAN MAIN***************/<br /> <br />
<br />


/***************FANTAN ONE(1)*************/<br /> <br />
<br />
/***************FANTAN ONE(1)*************/<br /> <br />
<br />


/***************FANTAN TWO(2)*************/<br /> <br />
*odd(one): when sum of the last three numbers is odd eg. x,x,1,1,1<br />
*even(pair): when sum of the last three numbers is even. eg. x,x,1,1,2<br />
*fan 1, 2, 3, 4: when the sum of the last three numbers divided by 4 gives a remainder of 1, 2, 3, 0. respectively. same
as fan 1, 2, 3, 4 in main<br />
/***************FANTAN TWO(2)*************/<br /> <br />
<br />


/******************SUM OF*****************/<br /> <br />
<br />
****Sum of The Last Three****<br />
*if sum of last three is between (0-3), (4-7), (8-11), (12-15), (16-19), (20-23), (24-27), they are classified
*as "red", "orange", "yellow", "green", "blue", "blue", "purple" respectively.<br />
*big, small, odd(one), even(pair) has the same explanation as in main but involves only last three numbers<br />

****Special Form****<br />
*right:
*most:
*more:
*full size:
*full order:
*no match:
*little more:
*Shuang Duo:
*all small:
*full double:
/******************SUM OF*****************/<br /> <br />



/*******************BACK******************/<br /> <br />
<br />

/*******************BACK******************/<br /> <br />
<br />

*Number equal to the sum of the last three numbers is selected on draw.


/****************POSITIONING**************/<br /> <br />
(big, small, odd(one), even(pair))
*Ten thousand: the value of the
/****************POSITIONING**************/<br /> <br />
<br />